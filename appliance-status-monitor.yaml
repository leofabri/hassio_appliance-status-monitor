blueprint:
  name: ASM - Monitor the state of an appliance - by leofabri
  description: >-
    `- Version: 3.0.0 -`


    ASM ('Appliance State Monitor') is an automation that can detect and monitor the state of your appliances through smart plugs.


    The blueprint is intended to be universal and versatile. You can use it with anything that consumes energy.

    You be able to pair this project with other automations and services.

    For instance, if you want to send alerts when the washing machine is not resuming a job, you want to send TTS notifications, or if 
    your fridge is somehow not behaving correctly and de-icing you can see that happening. Do you want to turn your TV off when nobody is watching
    it? No problem. All you need is just a little bit of creativity. 

    The [state machine](https://github.com/leofabri/hassio_appliance-status-monitor#features) is extensible, and you can run custom actions for each state change.


    In the setup process I will refer to the appliance's operations with the generic word 'job'. A 'job' could be anything (washing, rinsing, etc.), 
    you can later specify what that word means in your case.


    <strong>First setup?</strong> <i>[Follow the instructions](https://github.com/leofabri/hassio_appliance-status-monitor)</i>
  domain: automation
  input:
    appliance_socket:
      name: Appliance Smart Socket
      description: >-
        (*REQUIRED | switch)


        The socket that is used to control this appliance.
      default: []
      selector:
        entity:
          domain: switch
    appliance_power_sensor:
      name: Appliance Power Consumption
      description: >-
        (*REQUIRED | sensor | [ Unit: Watt ])


        The power entity reporting the current power usage in Watts.
      default: []
      selector:
        entity:
          domain: sensor
          device_class: power
          multiple: false
    appliance_starting_power_threshold:
      name: Starting power threshold
      description: >-
        (*REQUIRED)


        Power threshold above which we assume the appliance has started
        a new job or is resuming the current one (job_ongoing state).


        The **Starting Power threshold** must always be **>** than the **Finishing Power threshold**.
      default: 5
      selector:
        number:
          min: 1.0
          max: 1000.0
          unit_of_measurement: W
          mode: slider
          step: 1.0

    # TIMER delayed_job_ongoing_timer
    delayed_job_ongoing_timer:
      name: Delayed Job Ongoing timer
      description: >-
        (*REQUIRED | Helper | Name: <i><strong><your_appliance_name>_delayed_job_ongoing_timer</i></strong> | [?](https://github.com/leofabri/hassio_appliance-status-monitor/blob/b71e28faca532a8a0192e43433e91ce958025d58/home%20assistant/packages/universal/asm_your_appliance_name.yaml#L21))


        The timer that will allow to 'wait' & 'see' before assuming that a new job has started.
      default: []
      selector:
        entity:
          domain: timer

    delayed_job_ongoing_duration:
      name: Delayed Job Ongoing duration
      description: >-
        (OPTIONAL | <i><strong>Suggested: 0, Default: 0 | DISABLED</strong></i>)


        During a job cycle, some appliances may intermittently use more power than the starting power threshold, 
        thus entering the job_ongoing state (even when the job is not really started).

        With this value set, the automation will wait for the indicated time in seconds, and see if in that timespan the power consumption stays higher than the starting power threshold.

        ...

        <i><strong>WARNING:</strong> Setting a duration introduces a delay on the transition to the 'job_ongoing' state.
        Please make sure that you really need this, or leave it 0 if unsure.</i>
      default: 0.0
      selector:
        number:
          min: 0.0
          max: 900.0
          step: 1.0
          unit_of_measurement: seconds
          mode: slider
    appliance_finishing_power_threshold:
      name: Finishing power threshold
      description: >-
        (*REQUIRED)

        Power threshold below which we assume the appliance has finished
        a job (job_completed state).


        The **Finishing Power threshold** must always be **<** than the **Starting Power threshold**.
      default: 3.0
      selector:
        number:
          min: 0.1
          max: 1000.0
          unit_of_measurement: W
          mode: slider
          step: 0.1
    delayed_job_completion_duration:
      name: Delayed Job Completion duration
      description: >-
        (OPTIONAL | <i><strong>Suggested: 0, Default: 0 | DISABLED</strong></i>)


        During a job cycle, some appliances may intermittently use less power than the finishing power threshold, 
        thus entering the job_completed state (even when the job is not finished).

        With this value set, the automation will wait for the indicated time in seconds, and monitor during that period the power consumption rises again.

        ...

        <i><strong>WARNING:</strong> Setting a duration introduces a delay on the transition to the 'job_completed' state.
        Please make sure that you really need this, or leave it 0 if unsure.</i>
      default: 0.0
      selector:
        number:
          min: 0.0
          max: 900.0
          step: 1.0
          unit_of_measurement: seconds
          mode: slider
    appliance_overload_state_enabled:
      name: Appliance Overload State Enabled
      description: >-
        (*REQUIRED)


        Activate this if you want your appliance to use the overload states.
        Note: If you enable this one, you alsoo need the "Appliance Suspsended entity".

        ...

        <i><strong>WARNING:</strong> There is [a bug in Home Assistant](https://community.home-assistant.io/t/blueprint-booleans-not-saving-after-deployment/440382/2) that causes the UI to ignore the update 
        the value of inputs like this. Sometimes, you'll have to go to Edit in YAML and define 
        'appliance_overload_state_enabled: true/false' to solve the issue.

      default: false
      selector:
        boolean:
    appliance_job_completed_when_socket_is_off:
      name: Consider the 'job_completed' when the socket is off
      description: >-
        (*REQUIRED)


        Activate this if you want the state machine to transition to the 'job_completed' if the socket is is detected as unplugged.
        Note: A perfect use case for this option is with TVs and other appliances that may be normally unpowered.
        This is based on the assumption that: if the appliance is not powered, its job is done.

        ...

        <i><strong>WARNING:</strong> There is [a bug in Home Assistant](https://community.home-assistant.io/t/blueprint-booleans-not-saving-after-deployment/440382/2) that causes the UI to ignore the update 
        the value of inputs like this. Sometimes, you'll have to go to Edit in YAML and define 
        'appliance_job_completed_when_socket_is_off: true/false' to solve the issue.

      default: false
      selector:
        boolean:
    appliance_suspended_sensor:
      name: Appliance Suspended Overload entity
      description: >-
        (OPTIONAL but <u>*REQUIRED if Appliance Overload State Enabled is ON</u>)


        An input_number variable that turns into a value > 0 when an overload occurs. That would
        indicate that the machine was disconnected.
      default: []
      selector:
        entity:
          domain: input_number
    appliance_state_machine:
      name: Appliance State Machine
      description: >-
        (*REQUIRED | Helper | Name: <i><strong><your_appliance_name>_state_machine</strong></i> | [?](https://github.com/leofabri/hassio_appliance-status-monitor/blob/main/home%20assistant/packages/your_appliance_name.yaml#L18))


        The State Machine entity of this appliance.
      default: []
      selector:
        entity:
          domain: input_select
    appliance_job_cycle:
      name: Appliance Job Cycle
      description: >-
        (*REQUIRED | Helper | Name: <i><strong><your_appliance_name>_job_cycle</strong></i> | [?](https://github.com/leofabri/hassio_appliance-status-monitor/blob/b71e28faca532a8a0192e43433e91ce958025d58/home%20assistant/packages/universal/asm_your_appliance_name.yaml#L33))


        A variable that stores whether the appliance is still in a job cycle
        or not.<br>

        This is a boolean (so: 0 or 1).<br> <strong>off</strong> -> the appliance is
        not doing any job<br> <strong>on</strong> -> the job is incomplete.
        <br>

        <strong>Note that this bare entity does not provide any information about the detailed status
        of the machine (like an overload stuation).</strong>
        <br>
      default: []
      selector:
        entity:
          domain: input_boolean

    # TIMER delayed_job_completion_timer
    delayed_job_completion_timer:
      name: Job Completion | Delayed Job Completion timer
      description: >-
        (*REQUIRED | Helper | Name: <i><strong><your_appliance_name>_delayed_job_completion_timer</i></strong> | [?](https://github.com/leofabri/hassio_appliance-status-monitor/blob/b71e28faca532a8a0192e43433e91ce958025d58/home%20assistant/packages/universal/asm_your_appliance_name.yaml#L15))


        The timer that will allow to 'wait' & 'see' before assuming that a job has been completed.
      default: []
      selector:
        entity:
          domain: timer

    # TIMER job_completed_persistence_timer
    job_completed_persistence_timer:
      name: Job completed | State persistence Timer
      description: >-
        (*REQUIRED | Helper | Name: <i><strong><your_appliance_name>_job_completed_persistence_timer</i></strong> | [?](https://github.com/leofabri/hassio_appliance-status-monitor/blob/b71e28faca532a8a0192e43433e91ce958025d58/home%20assistant/packages/universal/asm_your_appliance_name.yaml#L27))


        A timer that will allow to force the state machine into the job_completed state for some time. 
        If this value is not set, when a new power read comes in, the state machine will immediately go into 'idle'.
      default: []
      selector:
        entity:
          domain: timer

    job_completed_persistence_duration:
      name: Job completed | State Persistence Duration
      description: >-
        (OPTIONAL | <i><strong>Suggested: 300, Default: 300 | DISABLED</strong></i>)


        This defines for how long the blueprint should "wait" before transitioning from the job_completed -> idle state.
        Setting this to 0 will disable the option. This means that once the job has been done, if a new power reading is received, the state will immediately transition to 'idle'.
      default: 300
      selector:
        number:
          min: 0
          max: 3600
          step: 1
          unit_of_measurement: seconds
          mode: slider

    automation_self_trigger:
      name: Automation Self-triggering entity
      description: >-
        (*REQUIRED | Helper | Name: <i><strong><your_appliance_name>_automation_self_trigger</i></strong> | [?](https://github.com/leofabri/hassio_appliance-status-monitor/blob/b71e28faca532a8a0192e43433e91ce958025d58/home%20assistant/packages/universal/asm_your_appliance_name.yaml#L38))


        The in charge of triggering the execution of the automation when it changes from off -> on.

        Sometimes, if the power consumption of the appliance is perfectly steady (or 0), no other trigger will work, and the automation is stuck. This entity solves the problem.
      default: []
      selector:
        entity:
          domain: input_boolean

    #####################
    # FLAG: ACTIONS #
    #####################
    actions_new_job_cycle_begins:
      name: CUSTOM ACTION(S) | When a new job cycle begins
      description: >-
        Executed when the appliance starts a new job cycle (<strong>idle -> job_ongoing</strong>
        state).

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:
    actions_job_cycle_resumes:
      name: CUSTOM ACTION(S) | When a job cycle resumes
      description: >-
        Executed when a pending job cycle is resumed (<strong>paused | unplugged | detached_overload -> job_ongoing</strong>
        state).
        Note that in this situation, the job cycle indicator is still on. That's how I know that the appliance is resuming and not startig a job.

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:

    actions_job_cycle_ends:
      name: CUSTOM ACTION(S) | When a job cycle is finished
      description: >-
        Executed when the appliance finishes a job cycle (<strong>job_ongoing -> job_completed</strong>
        state).

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:
    actions_unplugged_overload:
      name: CUSTOM ACTION(S) | When an overload occurs
      description: >-
        Executed when the appliance is detected as unplugged (because of an overload
        situation).

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:
    actions_paused_after_overload:
      name: CUSTOM ACTION(S) | When the overload situation is solved, now paused
      description: >-
        Executed when the state changes from <strong>detached_overload -> paused</strong> (NOT resuming the job).

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:
    actions_resuming_after_overload:
      name: CUSTOM ACTION(S) | When the overload situation is solved, now resuming
      description: >-
        Executed when the state changes from <strong>detached_overload -> job_ongoing</strong> (resuming the previous job).

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:
    actions_paused_after_unplugged:
      name: CUSTOM ACTION(S) | When the appliance is plugged back in, now paused
      description: >-
        Executed when the state changes from <strong>unplugged -> paused</strong> (NOT resuming the job).

        ...

        <i>**WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, TTS, waits, or anything that takes time to execute. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things like scripts.</i>

        If you need to use it for time-consuming operations, you have two options: dispatch the work by calling other scripts, or use the State Machine entity to wake up other external automations.
      default: []
      selector:
        action:

  source_url: https://github.com/leofabri/hassio_appliance-status-monitor/blob/main/appliance-status-monitor.yaml

# FLAG: Variables
variables:
  # Socket info
  appliance_socket: !input "appliance_socket"
  appliance_suspended_sensor: !input "appliance_suspended_sensor"

  # Delays
  delayed_job_ongoing_duration: !input "delayed_job_ongoing_duration" # precedes job_start
  delayed_job_completion_duration: !input "delayed_job_completion_duration" # precedes job_completed
  job_completed_persistence_duration: !input "job_completed_persistence_duration"

  # Timer entities
  delayed_job_ongoing_timer: !input "delayed_job_ongoing_timer" # precedes job_start
  delayed_job_completion_timer: !input "delayed_job_completion_timer" # precedes job_completed
  job_completed_persistence_timer: !input "job_completed_persistence_timer"

  # Blueprint settings
  appliance_overload_state_enabled: !input "appliance_overload_state_enabled"
  appliance_job_completed_when_socket_is_off: !input "appliance_job_completed_when_socket_is_off"

  LOG_WAIT: "WAIT"
  LOG_STATE_CHANGE: "STATE CHANGE"
  LOG_TIMER: "TIMER"
  LOG_CYCLE_START: "CYCLE START"
  LOG_CYCLE_END: "CYCLE END"
  LOG_CUSTOM_ACTIONS: "CUSTOM ACTIONS"
  LOG_POWER_THRESHOLD: "POWER_THRESHOLD"
  LOG_LEVEL: debug
  LOG_LOGGER: homeassistant.components.asm_blueprint

# FLAG: Triggers
trigger:
  - platform: state
    entity_id: !input "appliance_power_sensor"
    id: power_event
  - platform: state
    entity_id: !input "appliance_socket"
    id: socket_state_change_event

  - platform: state
    entity_id: !input "appliance_state_machine"
    from: detached_overload
    to: paused
    id: paused_after_overload_event
  - platform: state
    entity_id: !input "appliance_state_machine"
    from: unplugged
    to: paused
    id: paused_after_unplugged_event
  - platform: state
    entity_id: !input "appliance_state_machine"
    from: detached_overload
    to: job_ongoing
    id: resuming_after_paused_overload_event

  - platform: state
    entity_id: !input "automation_self_trigger"
    from: "off"
    to: "on"
    id: automation_self_triggered

  # EVENTS from timers
  - platform: event
    event_type: timer.finished
    event_data:
      entity_id: !input "delayed_job_ongoing_timer"
    id: job_started_timer_finished
  - platform: event
    event_type: timer.finished
    event_data:
      entity_id: !input "delayed_job_completion_timer"
    id: job_completed_timer_finished
  - platform: event
    event_type: timer.finished
    event_data:
      entity_id: !input "job_completed_persistence_timer"
    id: job_completed_persistence_timer_finished
  # ----

  # EVENTS from Home Assistant
  - platform: homeassistant
    event: start
    id: home_assistant_started_event
  - platform: event
    event_type:
      - automation_reloaded
    id: automation_reloaded_event
  # ----

condition:
  # Accepted triggers:
  - condition: or
    conditions:
      - condition: trigger
        id: power_event
      - condition: trigger
        id: socket_state_change_event
      - condition: trigger
        id: paused_after_overload_event
      - condition: trigger
        id: paused_after_unplugged_event
      - condition: trigger
        id: resuming_after_paused_overload_event
      - condition: trigger
        id: automation_self_triggered
      - condition: trigger
        id: job_started_timer_finished
      - condition: trigger
        id: job_completed_timer_finished
      - condition: trigger
        id: job_completed_persistence_timer_finished
      - condition: trigger
        id: home_assistant_started_event
      - condition: trigger
        id: automation_reloaded_event

# FLAG: Logic
action:
  - service: input_boolean.turn_off
    data: {}
    target:
      entity_id: !input "automation_self_trigger"

  ##################################################
  # NOTE: "detached_overload" state handling logic #
  ##################################################
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ appliance_overload_state_enabled }}
          - condition: template
            value_template: "{{ states(appliance_suspended_sensor) | float > 0.0 }}"
          - condition: state
            entity_id: !input "appliance_job_cycle"
            state: "on"
        sequence:
          - condition: not
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: detached_overload
          - service: input_select.select_option
            data:
              option: detached_overload # FLAG: detached_overload STATE TRANSITION
            target:
              entity_id: !input "appliance_state_machine"
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_STATE_CHANGE }} - Entered the detached_overload state."
          # ***********************
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_unplugged_overload."
          # ***********************
          - choose: []
            default: !input "actions_unplugged_overload"

  ##################################################
  # NOTE: "paused" state handling logic            #
  ##################################################
  - choose:
      - conditions:
          - condition: state
            entity_id: !input "appliance_job_cycle"
            state: "on"
          - condition: template
            value_template: "{% if appliance_overload_state_enabled %}{{ states(appliance_suspended_sensor) | float <= 0.0 }}{% else %}true{% endif %}"
          - condition: template
            value_template: "{{ states(appliance_socket) == 'on' }}"
          - condition: numeric_state
            entity_id: !input "appliance_power_sensor"
            below: !input "appliance_finishing_power_threshold"
          - condition: or
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: detached_overload
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: unplugged
          - condition: not
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: paused
        sequence:
          - service: input_select.select_option
            data:
              option: paused # FLAG: paused STATE TRANSITION
            target:
              entity_id: !input "appliance_state_machine"
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_STATE_CHANGE }} - Entered the paused state."
          # ***********************

        ##################################################
        # NOTE: "unplugged" state handling logic         #
        ##################################################
      - conditions:
          - condition: template
            value_template: "{{ states(appliance_socket) == 'off' }}"
          - condition: not
            conditions:
              - condition: template
                value_template: "{% if appliance_overload_state_enabled %}{{ states(appliance_suspended_sensor) | float > 0.0 }}{% else %}false{% endif %}"
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: detached_overload
          # Check whether the socket option is enabled or disabled
          - condition: not
            conditions:
              - condition: template
                value_template: >
                  {{ appliance_job_completed_when_socket_is_off }}
        sequence:
          - condition: not
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: unplugged
          - service: input_select.select_option
            data:
              option: unplugged # FLAG: unplugged STATE TRANSITION
            target:
              entity_id: !input "appliance_state_machine"
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_STATE_CHANGE }} - Entered the unplugged state."
          # ***********************
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                sequence:
                  - service: timer.cancel
                    data: {}
                    target:
                      entity_id: !input "delayed_job_completion_timer"
                  # ***** LOG SECTION *****
                  - service: system_log.write
                    data_template:
                      level: "{{ LOG_LEVEL }}"
                      logger: "{{ LOG_LOGGER }}"
                      message: "{{ LOG_TIMER }} - delayed_job_completion_timer canceled and stopped."
                  # ***********************
      - conditions:
          - condition: trigger
            id: paused_after_overload_event
        sequence:
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_paused_after_overload."
          # ***********************
          - choose: []
            default: !input "actions_paused_after_overload"
      - conditions:
          - condition: trigger
            id: paused_after_unplugged_event
        sequence:
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_paused_after_unplugged."
          # ***********************
          - choose: []
            default: !input "actions_paused_after_unplugged"
      - conditions:
          - condition: trigger
            id: resuming_after_paused_overload_event
        sequence:
          # ***** LOG SECTION *****
          - service: system_log.write
            data_template:
              level: "{{ LOG_LEVEL }}"
              logger: "{{ LOG_LOGGER }}"
              message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_resuming_after_overload."
          # ***********************
          - choose: []
            default: !input "actions_resuming_after_overload"
    default:
      ##################################################
      # NOTE: "job_ongoing" state handling logic       #
      ##################################################
      - choose:
          # IF (and)
          - conditions:
              # the socket is on
              - condition: template
                value_template: "{{ states(appliance_socket) == 'on' }}"
              # the power consumption > appliance_starting_power_threshold
              - condition: numeric_state
                entity_id: !input "appliance_power_sensor"
                above: !input "appliance_starting_power_threshold"
            sequence:
              # Delete the delayed_job_completion_timer if it's running
              # If the job completed timer is running, then the power consumption was high enough.
              # The delayed_job_completion_timer timer has to be discarded
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                    sequence:
                      - service: timer.cancel
                        data: {}
                        target:
                          entity_id: !input "delayed_job_completion_timer"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_TIMER }} - The starting power threshold was surpassed again => delayed_job_completion_timer canceled and stopped"
                      # ***********************
              - choose:
                  # IF
                  - conditions:
                      # Start the timer only if the state is not already job_ongoing
                      - condition: not
                        conditions:
                          - condition: state
                            entity_id: !input "appliance_state_machine"
                            state: job_ongoing
                      # the delayed_job_ongoing_timer isn't active
                      - condition: template
                        value_template: "{{ states(delayed_job_ongoing_timer) != 'active' }}"
                      # the job_completed_timer wasn't the one that triggered this automation
                      - condition: not
                        conditions:
                          - condition: trigger
                            id: job_started_timer_finished
                    sequence:
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_POWER_THRESHOLD }} - The starting power threshold was reached"
                      # ***********************
                      # Start the timer, start counting backwards
                      - service: timer.start
                        data: {}
                        target:
                          entity_id: !input "delayed_job_ongoing_timer"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_TIMER }} - delayed_job_ongoing_timer start invoked. Now it's {{ states(delayed_job_ongoing_timer) }}"
                      # ***********************
              - choose:
                  # if the timer should last for a time that is not 0
                  - conditions:
                      - condition: template
                        value_template: "{{ delayed_job_ongoing_duration > 0 }}"
                    sequence:
                      - choose:
                          # if the elapsed time is less than the wanted delayed_job_ongoing_duration
                          - conditions:
                              - condition: template
                                value_template: |-
                                  {% if states(delayed_job_ongoing_timer) == 'active' %}
                                    {% set t_expiring_date = state_attr(delayed_job_ongoing_timer, 'finishes_at') %}
                                    {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                    {% set t_total_duration = state_attr(delayed_job_ongoing_timer, 'duration') %}
                                    {% set duration_split = t_total_duration.split(':') %}
                                    {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                    {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                    {{ t_elapsed_sec < (delayed_job_ongoing_duration) | int }}
                                  {% else %}
                                    {{0}}
                                  {% endif %}
                            sequence:
                              # ***** LOG SECTION *****
                              - service: system_log.write
                                data_template:
                                  level: "{{ LOG_LEVEL }}"
                                  logger: "{{ LOG_LOGGER }}"
                                  message: "{{ LOG_WAIT }} - Waiting {{ delayed_job_ongoing_duration }} seconds, then I will decide if job_ongoing state should be entered."
                              # ***********************
                              # try to wait here until the remaining time is elapsed
                              - delay:
                                  seconds: |-
                                    {% if states(delayed_job_ongoing_timer) == 'active' %}
                                      {% set t_expiring_date = state_attr(delayed_job_ongoing_timer, 'finishes_at') %}
                                      {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                      {% set t_total_duration = state_attr(delayed_job_ongoing_timer, 'duration') %}
                                      {% set duration_split = t_total_duration.split(':') %}
                                      {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                      {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                      {% set t_remaining = ((delayed_job_ongoing_duration) | int) - t_elapsed_sec %}
                                      
                                      {{ 1 + t_remaining }}
                                    {% else %}
                                      {{ 1 + (delayed_job_ongoing_duration) | int }}
                                    {% endif %}
                              # if the delay is elapsed, self trig the atomation
                              - service: input_boolean.turn_on
                                data: {}
                                target:
                                  entity_id: !input "automation_self_trigger"
                              # make sure that the execution doesn't continue. So that the job_completed state is not reached.
                              - stop: ""
                default: [] # Do nothing. End
              - condition: not
                conditions:
                  - condition: state
                    entity_id: !input "appliance_state_machine"
                    state: job_ongoing
              - service: input_select.select_option
                data:
                  option: job_ongoing # FLAG: job_ongoing STATE TRANSITION
                target:
                  entity_id: !input "appliance_state_machine"
              # ***** LOG SECTION *****
              - service: system_log.write
                data_template:
                  level: "{{ LOG_LEVEL }}"
                  logger: "{{ LOG_LOGGER }}"
                  message: "{{ LOG_STATE_CHANGE }} - Entered the job_ongoing state."
              # ***********************
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_ongoing_timer) == 'active' }}"
                    sequence:
                      - service: timer.cancel
                        data: {}
                        target:
                          entity_id: !input "delayed_job_ongoing_timer"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_TIMER }} - delayed_job_ongoing_timer canceled and stopped."
                      # ***********************
              - choose:
                  - conditions:
                      - condition: state
                        entity_id: !input "appliance_job_cycle"
                        state: "off"
                    sequence:
                      - service: input_boolean.turn_on
                        data: {}
                        target:
                          entity_id: !input "appliance_job_cycle"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_CYCLE_START }} - A new Job Cycle started"
                      # ***********************
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_new_job_cycle_begins."
                      # ***********************
                      - choose: []
                        default: !input "actions_new_job_cycle_begins"
                default:
                  # ***** LOG SECTION *****
                  - service: system_log.write
                    data_template:
                      level: "{{ LOG_LEVEL }}"
                      logger: "{{ LOG_LOGGER }}"
                      message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_job_cycle_resumes."
                  # ***********************
                  - choose: []
                    default: !input "actions_job_cycle_resumes"

          ##################################################
          # NOTE: "job_completed" state handling logic     #
          ##################################################
          # IF
          - conditions:
              # The job is currently ongoing
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: job_ongoing
              # The job cycle is still in progress
              - condition: state
                entity_id: !input "appliance_job_cycle"
                state: "on"
              # A value below the finishing power threshold is received
              - condition: numeric_state
                entity_id: !input "appliance_power_sensor"
                below: !input "appliance_finishing_power_threshold"

              # If the socket is off and the
              - condition: or
                conditions:
                  # The socket is on
                  - condition: template
                    value_template: "{{ states(appliance_socket) == 'on' }}"
                  - condition: and
                    conditions:
                      # The option that forces the state machine to enter idle is on
                      - condition: template
                        value_template: "{{ appliance_job_completed_when_socket_is_off }}"
                      # The socket is off
                      - condition: template
                        value_template: "{{ states(appliance_socket) == 'off' }}"
            sequence:
              # ***** LOG SECTION *****
              - service: system_log.write
                data_template:
                  level: "{{ LOG_LEVEL }}"
                  logger: "{{ LOG_LOGGER }}"
                  message: "{{ LOG_POWER_THRESHOLD }} - The finishing power threshold was reached"
              # ***********************
              - choose:
                  # IF
                  - conditions:
                      - condition: not
                        conditions:
                          - condition: template
                            value_template: >
                              {{ appliance_job_completed_when_socket_is_off }}
                          # The socket is on
                          - condition: template
                            value_template: "{{ states(appliance_socket) == 'off' }}"

                      # If the state machine isn't already in the job_completed state
                      - condition: not
                        conditions:
                          - condition: state
                            entity_id: !input "appliance_state_machine"
                            state: job_completed
                      # the timer isn't active
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) != 'active' }}"
                      # the job_completed_timer didn't trigger this automation this time
                      - condition: not
                        conditions:
                          - condition: trigger
                            id: job_completed_timer_finished
                    sequence:
                      # Start the timer, start counting backwards
                      - service: timer.start
                        data: {}
                        target:
                          entity_id: !input "delayed_job_completion_timer"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_TIMER }} - delayed_job_completion_timer start invoked. Now it's {{ states(delayed_job_completion_timer) }}"
                      # ***********************
              - choose:
                  # if the timer should last for a time that is not 0
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                      - condition: template
                        value_template: "{{ delayed_job_completion_duration > 0 }}"
                    sequence:
                      - choose:
                          # if the elapsed time is less than the wanted delayed_job_completion_duration
                          - conditions:
                              - condition: not
                                conditions:
                                  - condition: template
                                    value_template: >
                                      {{ appliance_job_completed_when_socket_is_off }}
                              - condition: template
                                value_template: |-
                                  {% if states(delayed_job_completion_timer) == 'active' %}
                                    {% set t_expiring_date = state_attr(delayed_job_completion_timer, 'finishes_at') %}
                                    {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                    {% set t_total_duration = state_attr(delayed_job_completion_timer, 'duration') %}
                                    {% set duration_split = t_total_duration.split(':') %}
                                    {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                    {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                    {{ t_elapsed_sec < (delayed_job_completion_duration) | int }}
                                  {% else %}
                                    {{0}}
                                  {% endif %}
                            sequence:
                              # ***** LOG SECTION *****
                              - service: system_log.write
                                data_template:
                                  level: "{{ LOG_LEVEL }}"
                                  logger: "{{ LOG_LOGGER }}"
                                  message: "{{ LOG_WAIT }} - Waiting {{ delayed_job_completion_duration }} seconds, then I will decide if job_completed state should be entered."
                              # ***********************
                              - delay:
                                  seconds: |-
                                    {% if states(delayed_job_completion_timer) == 'active' %}
                                      {% set t_expiring_date = state_attr(delayed_job_completion_timer, 'finishes_at') %}
                                      {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                      {% set t_total_duration = state_attr(delayed_job_completion_timer, 'duration') %}
                                      {% set duration_split = t_total_duration.split(':') %}
                                      {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                      {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                      {% set t_remaining = ((delayed_job_completion_duration) | int) - t_elapsed_sec %}
                                      
                                      {{ 1 + t_remaining }}
                                    {% else %}
                                      {{ 1 + (delayed_job_completion_duration) | int }}
                                    {% endif %}
                              # if the delay is elapsed, self trig the atomation
                              - service: input_boolean.turn_on
                                data: {}
                                target:
                                  entity_id: !input "automation_self_trigger"
                              # make sure that the execution doesn't continue. So that the job_completed state is not reached.
                              - stop: ""
                default: [] # Do nothing. End
              - service: input_boolean.turn_off
                data: {}
                target:
                  entity_id: !input "appliance_job_cycle"
              - service: input_select.select_option
                data:
                  option: job_completed # FLAG: job_completed STATE TRANSITION
                target:
                  entity_id: !input "appliance_state_machine"
              # ***** LOG SECTION *****
              - service: system_log.write
                data_template:
                  level: "{{ LOG_LEVEL }}"
                  logger: "{{ LOG_LOGGER }}"
                  message: "{{ LOG_CYCLE_END }} - The Job Cycle is over"
              # ***********************
              # ***** LOG SECTION *****
              - service: system_log.write
                data_template:
                  level: "{{ LOG_LEVEL }}"
                  logger: "{{ LOG_LOGGER }}"
                  message: "{{ LOG_STATE_CHANGE }} - Entered the job_completed state."
              # ***********************
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                    sequence:
                      - service: timer.cancel
                        data: {}
                        target:
                          entity_id: !input "delayed_job_completion_timer"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_TIMER }} - delayed_job_completion_timer canceled and stopped."
                      # ***********************
              # ***** LOG SECTION *****
              - service: system_log.write
                data_template:
                  level: "{{ LOG_LEVEL }}"
                  logger: "{{ LOG_LOGGER }}"
                  message: "{{ LOG_CUSTOM_ACTIONS }} - executing actions_job_cycle_ends."
              # ***********************
              - choose: []
                default: !input "actions_job_cycle_ends"
              - choose:
                  - conditions:
                      - condition: or
                        conditions:
                          - condition: trigger
                            id: automation_self_triggered
                          - condition: template
                            value_template: "{{ delayed_job_completion_duration <= 0 }}"
                          - condition: template
                            value_template: >
                              {{ appliance_job_completed_when_socket_is_off }}
                    sequence:
                      # - delay:
                      #     minutes: 1
                      # Self trigger once more to move to the idle state
                      - service: input_boolean.turn_on
                        data: {}
                        target:
                          entity_id: !input "automation_self_trigger"
        default:
          ##################################################
          # NOTE: "idle" state handling logic              #
          ##################################################
          - choose:
              - conditions:
                  - condition: state
                    entity_id: !input "appliance_job_cycle"
                    state: "off"
                  - condition: not
                    conditions:
                      - condition: state
                        entity_id: !input "appliance_state_machine"
                        state: idle
                sequence:
                  - choose:
                      # IF
                      - conditions:
                          # the job_completed_persistence_timer isn't active
                          - condition: template
                            value_template: "{{ states(job_completed_persistence_timer) != 'active' }}"
                          # the job_completed_timer didn't trigger this automation this time
                          - condition: not
                            conditions:
                              - condition: trigger
                                id: job_completed_persistence_timer_finished
                          # the state machine signals that a job is ongoing
                          # This is helpful when, for example, the socket is turned of and on immediately
                          # and whe need to reach the idle state ignoring the timer
                          - condition: state
                            entity_id: !input "appliance_state_machine"
                            state: job_completed
                        sequence:
                          # Start the timer, strart counting backwards
                          - service: timer.start
                            data: {}
                            target:
                              entity_id: !input "job_completed_persistence_timer"
                          # ***** LOG SECTION *****
                          - service: system_log.write
                            data_template:
                              level: "{{ LOG_LEVEL }}"
                              logger: "{{ LOG_LOGGER }}"
                              message: "{{ LOG_TIMER }} - job_completed_persistence_timer start invoked. Now it's {{ states(job_completed_persistence_timer) }}"
                          # ***********************
                  - choose:
                      # if the timer should last for a time that is not 0
                      - conditions:
                          - condition: template
                            value_template: "{{ job_completed_persistence_duration > 0 }}"
                        sequence:
                          - choose:
                              # if the elapsed time is less than the wanted job_completed_persistence_duration
                              - conditions:
                                  - condition: template
                                    value_template: |-
                                      {% if states(job_completed_persistence_timer) == 'active' %}
                                        {% set t_expiring_date = state_attr(job_completed_persistence_timer, 'finishes_at') %}
                                        {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                        {% set t_total_duration = state_attr(job_completed_persistence_timer, 'duration') %}
                                        {% set duration_split = t_total_duration.split(':') %}
                                        {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                        {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                        {{ t_elapsed_sec < (job_completed_persistence_duration) | int }}
                                      {% else %}
                                        {{0}}
                                      {% endif %}
                                sequence:
                                  # ***** LOG SECTION *****
                                  - service: system_log.write
                                    data_template:
                                      level: "{{ LOG_LEVEL }}"
                                      logger: "{{ LOG_LOGGER }}"
                                      message: "{{ LOG_WAIT }} - Waiting {{ job_completed_persistence_duration }} seconds, then I will decide if idle state should be entered."
                                  # ***********************
                                  - delay:
                                      seconds: |-
                                        {% if states(job_completed_persistence_timer) == 'active' %}
                                          {% set t_expiring_date = state_attr(job_completed_persistence_timer, 'finishes_at') %}
                                          {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                          {% set t_total_duration = state_attr(job_completed_persistence_timer, 'duration') %}
                                          {% set duration_split = t_total_duration.split(':') %}
                                          {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                          {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                          {% set t_remaining = ((job_completed_persistence_duration) | int) - t_elapsed_sec %}
                                          
                                          {{ 1 + t_remaining }}
                                        {% else %}
                                          {{ 1 + (job_completed_persistence_duration) | int }}
                                        {% endif %}
                                  # if the delay is elapsed, self trig the atomation
                                  - service: input_boolean.turn_on
                                    data: {}
                                    target:
                                      entity_id: !input "automation_self_trigger"
                                  # make sure that the execution doesn't continue. So that the job_completed state is not reached
                                  - stop: ""
                    default: [] # Do nothing. End
                  # Go to idle
                  - service: input_select.select_option
                    data:
                      option: idle # FLAG: idle STATE TRANSITION
                    target:
                      entity_id: !input "appliance_state_machine"
                  # ***** LOG SECTION *****
                  - service: system_log.write
                    data_template:
                      level: "{{ LOG_LEVEL }}"
                      logger: "{{ LOG_LOGGER }}"
                      message: "{{ LOG_STATE_CHANGE }} - Entered the idle state."
                  # ***********************
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ states(job_completed_persistence_timer) == 'active' }}"
                        sequence:
                          - service: timer.cancel
                            data: {}
                            target:
                              entity_id: !input "job_completed_persistence_timer"
                          # ***** LOG SECTION *****
                          - service: system_log.write
                            data_template:
                              level: "{{ LOG_LEVEL }}"
                              logger: "{{ LOG_LOGGER }}"
                              message: "{{ LOG_TIMER }} - job_completed_persistence_timer canceled and stopped."
                          # ***********************
            default:
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_ongoing_timer) == 'active' }}"
                    sequence:
                      - service: timer.cancel
                        data: {}
                        target:
                          entity_id: !input "delayed_job_ongoing_timer"
                      # ***** LOG SECTION *****
                      - service: system_log.write
                        data_template:
                          level: "{{ LOG_LEVEL }}"
                          logger: "{{ LOG_LOGGER }}"
                          message: "{{ LOG_TIMER }} - delayed_job_ongoing_timer canceled and stopped."
mode: restart
max_exceeded: silent
trace:
  stored_traces: 10
